package client2;

import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * @author srish
 * EventBuffer holds 2 ConcurrentLinkedQueues that are threadsafe.
 * The events and json payloads generated by Producer are stored here for client threads' consumption
 */

public class EventBuffer {
    private ConcurrentLinkedQueue<String> events = new ConcurrentLinkedQueue<>();
    private ConcurrentLinkedQueue<String> payloads = new ConcurrentLinkedQueue<>();
    private boolean emptyEvents = true;
    private boolean emptyPayloads = true;



    /**
     * Returns a lift ride entry from the queue for the client usage.
     * @return lift ride event specified as path parameters in the swagger API format for POST request
     */
    public synchronized String retrieveEvent() {
        String returnable;
        //if the events queue is empty wait until it is populated
        while (emptyEvents) {
            try {
                System.out.println(Thread.currentThread()+ " Waiting for a event generation");
                wait();
            } catch (InterruptedException e) {
                System.out.println(e.getMessage());
            }
        }
        // no longer empty, hence inform all
        notifyAll();
        //Retrieve an event entry from queue
        returnable = events.remove();
        if (!returnable.equals("FIN")){     //Producer hasn't finished production
            if (events.isEmpty()){  //If queue is empty after this retrieval, mark it as empty
                emptyEvents = true;
            }
        } else {    // Producer has finished consumption
            events.add("FIN");  //Add FIN back again so other threads too, know that production is over
        }
        return returnable;
    }


    /**
     * Returns a payload entry from the queue for the client usage.
     * @return json payload in string format for client usage
     */
    public synchronized String retrievePayload() {
        String returnable;
        //if the payload queue is empty wait until it is populated
        while (emptyPayloads) {
            try {
                System.out.println(Thread.currentThread()+ " Waiting for a payload generation");
                wait();
            } catch (InterruptedException e) {
                System.out.println(e.getMessage());
            }
        }
        // no longer empty, hence inform all
        notifyAll();
        //Retrieve an event entry from queue
        returnable = payloads.remove();
        if (!returnable.equals("FIN")){     //Producer hasn't finished production
            if (payloads.isEmpty()){        //If queue is empty after this retrieval mark it as empty
                emptyPayloads = true;
            }
        } else {        // Producer has finished consumption
            payloads.add("FIN");    //Add FIN back again so other threads too, know that production is over
        }
        return returnable;
    }

    /**
     * Adds new event to the queue for client assumption
     * @param event A randomly generated lift ride event specified as path parameters
     *              in the swagger API format for POST request
     */
    public synchronized void putEvent(String event) {
        if(events.isEmpty()){
            notifyAll();      //if events queue wqs previously empty, inform all consumer about the new addition
        }
        emptyEvents = false;
        events.add(event);  //add event to queue
    }

    /**
     * Adds new payload to the queue for client consumption
     * @param payload A randomly generated json payload in string format
     */
    public synchronized void putPayload(String payload) {
        if(payloads.isEmpty()){
            notifyAll();        //if payload queue wqs previously empty, inform all consumer about the new addition
        }
        emptyPayloads = false;
        payloads.add(payload);  //add payload to queue
    }
}
